---
pagetitle: >-
    Phonological processes as transductions
---

# Phonological processes as transductions

We have spent a fair amount of time on FSTs by now, but we still haven't seen a truly compelling reason for using them as a formal model of phonology.
So far, our only observation has been that FSTs allow us to rewrite one string into another, which would allow us to relate underlying representations (URs) in phonology to their corresponding surface forms.
But this is really underselling FSTs as a model of phonology.
What is impressive about FSTs is that they use a single core mechanic --- connecting finitely many states via transitions that have input:output labels --- yet get tremendous phonological mileage out of it.
FSTs can handle local processes like assimilation and word-final devoicing, iterated local processes like vowel harmony, unbounded dependencies and tiers, blocking, rule ordering, and much more.
They truly are a phonological swiss army knife, except that it is a swiss army knife that does everything with just one blade.

## Progressive assimilation

Let us start with a very simple example.
In colloquial speech, *n* often is pronounced *m* immediately after *p*.
For example, somebody might say *cap'm* instead of *cap'n* as the short form of *captain*.
This is an instance of **progressive assimilation**.
Phonologists would describe this with a **rewrite rule** of the form

$$\mathrm{n} \rightarrow \mathrm{m} \mid \mathrm{p} \_$$

which is read as "*n* becomes *m* in any context where *n* immediately appears to the right of *p*".
Specifically, the rule has a left half and right half, separated by the pipe symbol `|`.
The left half tells us what sound changes in what manner, and the right half tells us the context, with the underscore `_` representing the position of the sound undergoing the change.
Rewrite rules of this form are very common in the phonological literature and are also used in morphology (word structure).

We can also express this progressive assimilation very easily in the form of an FST.
Again we may use the tabular format or the graph-based one in order to specify the FST.
For the sake of succinctness, we assume that the only input symbols are *m*, *n*, *p*, and *x*.
A realistic FST would have many more input symbols, but they would all be treated exactly the same as *x* here.

|           |                                    |                              |             |                         |
| --:       | :-:                                | :-:                          | :-:         | :-:                     |
|           | **0**                              | **P**                        | **Initial** | **Final**               |
| **0**     | m:m, n:n, x:x                      | p:p                          | Yes         | {{{R}}}:$\emptystring$  |
| **P**     | m:m, n:m, x:x                      | p:p                          | No          | {{{R}}}:$\emptystring$  |

~~~ {.include-tikz size=mid}
progressiveassimilation.tikz
~~~

This transducer leaves almost all input symbols unchanged.
If it sees a *p*, it moves into the state *P*, and only at this point, if the next symbol it sees is *n*, does it do some rewriting and output *m* instead.
The key strategy is to switch from the default state *0* to the special state *P* when the conditions for rewriting *n* as *m* are met.
Once we are in the state, we go back to *0* the moment the conditions for assimilation are no longer met, either because we have already carried out the assimilation step, or because we have encountered other input symbols that have disrupted the conditions for assimilation.

::: exercise
For each one of the URs below, compute the corresponding surface form generated by the FST for progressive assimilation above.
Don't forget to add {{{R}}} at the end of the input string.

- xxpmx
- xxpnx
- xpmnx
- xpnnx

:::

::: exercise
Many language do not like consonant clusters of three or more consonants in a row.
Using the strategy illustrated above, construct an FST that deletes all consonants in a cluster except the first two.
For the sake of simplicity, assume that the input alphabet only consists of C for consonants and V for vowels.
For example, you may have the input string CCVCCCCV, and it should be rewritten as CCVCCV.
:::

## The challenges of regressive assimilation

Whereas progressive assimilation proceeds from left-to-right, **regressive assimilation** proceeds from right-to-left.
For example, the word *white board* is commonly pronounced like *wipe board* because the *b* in *board* causes the preceding *t* in *white* to become a *p*.
The rewrite rule for that would be

$$\mathrm{t} \rightarrow \mathrm{p} \mid \_ \mathrm{b}$$

Notice how the conditioning environment now occurs after the sound that undergoes assimilation.
At first sight it may seem that our FST cannot handle regressive assimilation patterns.
Since the FST moves through the input from left-to-right and does not get to look ahead, it does not know what to do when it encounters a *t*.
Maybe it will be followed by a *b*, in which case it should be rewritten as *p*, or maybe *t* won't be followed by *b*, in which case it should stay a *t*.
How could the FST figure out which one is the right option?

There are three different ways to handle this, and we will look at each one in turn:

- Switching to a non-deterministic FST
- Running the FST from right to left instead
- Using the **delayed output strategy** with **final emissions**

The first solution uses a non-deterministic FST.
Recall that an FST is non-deterministic iff there are choice points.
This can be because there are multiple initial states or multiple applicable transitions.
And it is total iff it produces an output for every input string.
Below is a non-deterministic FST that correctly rewrites *t* as *p* before *b*.

|           |                   |               |               |             |                                  |
| --:       | :-:               | :-:           | :-:           | :-:         | :-:                              |
|           | **0**             | **P**         | **T**         | **Initial** | **Final**                        |
| **0**     | b:b, p:p, x:x     | t:p           | t:t           | Yes         | {{{R}}}:$\emptystring$           |
| **P**     | b:b               |               |               | No          | -                                |
| **T**     | p:p, t:t, x:x     | t:p           |               | No          | {{{R}}}:$\emptystring$           |

~~~ {.include-tikz size=mid}
regressiveassimilation.tikz
~~~

This transducer provides a choice point when we are in state 0 and encounter *t*: we may keep *t* as *t* and switch into state *T*, or we may rewrite *t* as *p* and switch into state *P*.
Notice that state *T* has no outgoing transition with *b* as an input symbol.
So if the next input symbol is indeed *b* and the transducer is in state *T*, then it gets stuck.
This enforces that *t* cannot stay *t* when followed by *b*.
By contrast, state *P* only has one outgoing transition which must have *b* as its input symbol.
So if the transducer decides to rewrite *t* as *p* but there is no *b* after *t*, the transducer once again gets stuck.
This ensures that *t* must be rewritten as *p* when followed by *b*.
Taken together, we get that *t* is rewritten as *p* iff it is followed by *b*, which is exactly what the rewrite rule says.

::: exercise
For each one of the URs below, compute the corresponding surface form generated by the non-deterministic FST for regressive assimilation above.
Don't forget to add {{{R}}} at the end of the input string.

- xxb
- xxt
- xxtbtx

:::

We can conclude, then, that regressive assimilation can be handled with non-deterministic FSTs, but that's no exactly surprising because non-deterministic FSTs are a lot more powerful than total deterministic FSTs.
Ideally, we make do with the latter as much as possible.
Fortunately we have two more options for handling regressive assimilation, and those allow us to keep the FST total and deterministic.

Consider then the second option, which is to simply change the direction in which the FST processes the string.
Rather than moving through the input from left to right, the transducer moves through it from right to left.
In this case the FST always knows whether *t* is followed by *b* because it sees the symbol immediately to the right of *t* **before** it encounters *t*, rather than afterwards.
For an FST moving from right-to-left, regressive assimilation is just progressive assimilation.

We can make this fully explicit in formal terms by treating right-to-left transducers as left-to-right transducers with a string reversal operation.
A right-to-left FST works as follows: mirror the input, run the left-to-right FST, then mirror the output.

::: definition
Given an FST $T$, the corresponding **right-to-left** FST $T_{R2L}$ maps input string $i_1 \cdots i_m{{{R}}}$ to output string $o_1 \cdots o_n$ iff
$T$ maps $i_m \cdots i_1 {{{R}}}$ to $o_n \cdots o_1$.
:::

::: example
Consider once more the (deterministic and total) FST for progressive assimilation of *n* to *m* after *p*.
When reading the input from left to right, it maps *xnpn{{{R}}}* to *xnpm*.
In right-to-left mode, on the other hand, it rewrites *xnpn{{{R}}}* as *xmpn* because from that direction, it is the left *n* that is encountered after *p*.

Here is how this follows from the definition above:

1. Let us use $T$ to refer to the progressive assimilation transducer.
   Its right-to-left counterpart is $T_{R2L}$, and we want to know what output $T_{R2L}$ produces for the input *xnpn{{{R}}}*.
1. By our definition, we can determine this output from the output of $T$ for *npnx{{{R}}}*, the mirror image of *xnpn{{{R}}}*
1. $T$ maps *npnx{{{R}}}* to *npmx{{{R}}}*.
1. The mirror image of the output *npmx{{{R}}}* is *xmpn{{{R}}}*, which is exactly the output $T_{R2L}$ generates from the input *xnpn{{{R}}}*.
1. Overall, $T_{R2L}$ maps *xnpn{{{R}}}* to *xmpn{{{R}}}*, which is a case of regressive assimilation.
:::

::: exercise
Design an FST $T$ such that $T_{R2L}$ captures the regressive assimilation rule
$\mathrm{t} \rightarrow \mathrm{p} \mid \_ \mathrm{b}$.
:::

This account says that progressive and regressive assimilation are fundamentally the same mechanism, they only differ in whether one processes the string left-to-right or right-to-left.
Still, sometimes it is helpful to have all transducers operate left-to-right, so let us look at our third solution, which keeps the FST deterministic, total, and left-to-right.
Rather than having the left-to-right FST make a non-deterministic guess about whether the current *t* should be rewritten as *t* or *p*, we can make it hold off on the rewriting until more of the input string has been seen.
This is the **delayed output strategy**, and it exploits the fact that the output of a transition does not have to be exactly one symbol --- it can also be the empty string or a string of two or more output symbols.

|           |                         |                               |             |                         |
| --:       | :-:                     | :-:                           | :-:         | :-:                     |
|           | **0**                   | **T**                         | **Initial** | **Final**               |
| **0**     | b:b, p:p, x:x           | t:$\emptystring$              | Yes         | {{{R}}}:$\emptystring$  |
| **T**     | b:pb, p:tp, x:tx        | t:t                           | No          | {{{R}}}:$t$             |

~~~ {.include-tikz size=mid}
regressiveassimilation_delayedoutput_finalemission.tikz
~~~

This deterministic FST deletes *t* upon encountering it, but it switches to a different state *T* to keep track of the fact that a *t* has been deleted.
When it encounters a *b*, a *p*, or an *x*, the transducer transitions from *T* back to the default state *0*.
However, in doing so it also reinserts the deleted *t*, or rather, *t* or *p* depending on the symbol: with *p* and *x*, the deleted *t* is reinserted, whereas with *b*, a *p* is reinserted instead.
Hence a *t* followed by a *b* undergoes assimilation to *p* via a two-step procedure: deletion of *t* and rewriting of *b* as *pb*.
And this two-step procedure is exactly what the delayed output strategy is about.

::: exercise
For each one of the URs below, compute the corresponding surface form generated by the FST above that uses the delayed output strategy.
Don't forget to add {{{R}}} at the end of the input string.

1. xxptbx
1. txptbx
1. txptttbx
:::

::: exercise
What is the role of the transition *t:t* from state *T* to *T*?
:::

One important but easily missed part of this FST is the final transition for $T$.
Here, {{{R}}} is rewritten as *t*.
This is absolutely vital in ensuring that the delayed output strategy does not accidentally drop *t* at the end of the string.

::: example
Consider the UR *xt*, which corresponds to the input string *xt{{{R}}}*.
The transducer starts in state *0*, rewrites *x* as *x*, and transitions to state *0*.
After that, it sees *t* in the input and transitions from *0* to *T* while outputting nothing.
So at this point the output string consists only of *x*.
The FST then reads in *{{{R}}}*, outputs *t*, and then stops.
The previously deleted *t* is reinserted and the overall output is *xt*, as desired.
If the FST had not rewritten *{{{R}}}* as *t*, the output would have been *x*, which is incorrect.
:::

Outputs produced by rewriting {{{R}}} are also called **final emissions**.
When dealing with phonological rewrite rules, the delayed output strategy often requires the use of final emissions to make sure that sounds aren't accidentally deleted at the end of the word.

::: exercise
In a previous chapter, we encountered the process of word-final devoicing in German.
Inspired by this phenomenon, define two separate FSTs that replace word-final *z* with *s* and word-final *v* with *f*.
One transducer should operate right-to-left, the other one should use the delayed output strategy in combination with final emissions.

For each FST, you may write a table or draw a graph.
:::

::: exercise
The process of intervocalic voicing is also familiar from an earlier chapter.
Suppose that *s* is subject to intervocalic voicing::
$\mathrm{s} \rightarrow \mathrm{z} \mid \mathrm{V} \_ \mathrm{V}$.
You may assume that the only input symbols are *s*, *z*, *x*, and *V* (and of course {{{R}}}).
Define an FST for intervocalic voicing.
You may write a table or draw a graph.

Does your FST use the delayed output strategy?
What about the final emission trick?
:::

::: exercise
Continuing the previous exercise, answer the following question:
Can intervocalic voicing be captured by a (total, deterministic) right-to-left transducer without the delayed output strategy?
Justify your answer.
:::


## Iterativity/spreading for vowel harmony

Another process we are familiar with by now is vowel harmony.
We described Korean vowel harmony as a ban against mixing bright vowels (B) and mid-dark vowels (M) in the same word.
But at least some types of vowel harmony aren't just constraints on what vowels may be combined, they are processes that change non-harmonic vowels in the UR to harmonic vowels in the surface form.

Consider then a variant of Korean where vowel harmony causes non-harmonic vowels to be replaced by harmonic counterparts.
If the first vowel is B, all other vowels in the word become B, and if the first vowel is M, all other vowels in the word become M.
Can we do this with an FST?
Why yes, of course we can, just see below (assuming that our only input symbols are *B*, *M*, and *x* for anything else).

|           |         |                |                |             |                              |
| --:       | :-:     | :-:            | :-:            | :-:         | :-:                          |
|           | **0**   | **B**          | **M**          | **Initial** | **Final**                    |
| **0**     | x:x     | B:B            | M:M            | Yes         | {{{R}}}:$\emptystring$       |
| **B**     |         | B:B, M:B, x:x  |                | No          | {{{R}}}:$\emptystring$       |
| **M**     |         |                | B:M, M:M, x:x  | No          | {{{R}}}:$\emptystring$       |

~~~ {.include-tikz size=mid}
vowelharmony.tikz
~~~

This FST starts out in the default state *0*, but the very first time it encounters *B* or *M*, it switches into the corresponding state.
Once it is in one of those states, it rewrites all vowels into harmonic vowels.
Notice how this FST correctly captures the iterative nature of vowel harmony: changing one vowel to a harmonic form causes the next one to also undergo this change.
Each change is local in that it is triggered by the preceding vowel, but the process applies over and over again to spread the harmony across arbitrarily many vowels.

::: exercise
For each one of the URs below, compute the corresponding surface form.
Don't forget to add {{{R}}} at the end of the input string.

1. xBxxM
1. MxxBxxBxxM
1. MxxxxxxxxB

:::

::: exercise
Korean also has high dark vowels (H), which are neutral vowels.
That is to say, H can occur together with B or M and does not undergo vowel harmony.
Thus H stays H no matter what.
Revise the FST above so that it also handles H correctly.
:::

::: exercise
This continues the previous exercise.
The behavior of H in Korean is actually more involved.
When H is the first vowel of the word, it behaves like M in that it causes B to be rewritten as M.
Modify your revised FST from the previous exercise so that it handles this correctly, too.
:::

::: exercise
Suppose that vowel harmony were not iterative.
That is to say, the first vowel only controls the harmony for the second vowel, after that the third vowel controls the harmony for the fourth vowel, and so on.
For instance, *xBxMxMxB* would come out as *xBxBxMxM*.
Modify the FST above so that it captures this pattern (ignore H for this exercise)
:::

::: exercise
Now suppose that vowel harmony is even more restricted so that harmony never involves more than the first two vowels in the word.
For example, *xBxMxMxB* would now come out as *xBxBxMxB*.
Modify the FST above so that it captures this pattern (ignore H for this exercise).
:::

## Unboundedness and blocking without tiers

Another harmony process we have encountered before is sibilant harmony in Samala, which was noteworthy because it seems to be able to span arbitrary distances.
All sibilants in the word must be harmonic: they are either all *s*, or they are all *ʃ*, no matter how far apart they are from each other.
When we first encountered this phenomenon, we modeled it with tiers, but no such addition is needed for FSTs to capture the unbounded nature of sibilant harmony.

Consider what sibilant harmony would look like as a process that causes sibilants to change their form.
Suppose that the harmony is controlled by the first sibilant in the word (spoilers: this is not how it works for Samala).
If the first sibilant is *s*, then any subsequent instances of *ʃ* become *s*.
And if the first sibilant is *ʃ*, then any subsequent instances of *s* become *ʃ*.
Perhaps unsurprisingly, the corresponding FST looks almost the same as the one for vowel harmony.

|           |         |                |                |             |                     |
| --:       | :-:     | :-:            | :-:            | :-:         | :-:                 |
|           | **0**   | **ESS**        | **ESH**        | **Initial** | **Final**           |
| **0**     | x:x     | s:s            | ʃ:ʃ            | Yes         | Yes($\emptystring$) |
| **ESS**   |         | s:s, ʃ:s, x:x  |                | No          | Yes($\emptystring$) |
| **ESH**   |         |                | s:ʃ, ʃ:ʃ, x:x  | No          | Yes($\emptystring$) |

~~~ {.include-tikz size=mid}
sibilantharmony.tikz
~~~

::: exercise
For each one of the URs below, compute the corresponding surface form.
Don't forget to add {{{R}}} at the end of the input string.

1. xsxxʃ
1. ʃxxsxxsxxʃ
1. ʃxxxxxxxxs

:::

::: exercise
Slovenian has a version of sibilant harmony that is similar to Samala but harmony is blocked by an intervening *t*.
That is to say, the first sibilant after a *t* does not need to be harmonic with any of the sibilants to its left, but the sibilants to its right must be harmonic with that sibilant (unless another *t* intervenes).
Hence we get the following mappings between URs and surface forms:

- *xxsxxʃ* becomes *xxsxxs*
- *xxstxʃ* becomes *xxstxʃ*
- *xxstxʃxs* becomes *xxstxʃxʃ*
- *xxstxʃts* becomes *xxstxʃts*

Modify the FST above so that it incorporates blocking by *t*.
:::

::: exercise
Samala sibilant harmony is in fact regressive: the last sibilant determines what harmonic form the other sibilants must exhibit.
Answer the following questions and justify your answers:

1. Can Samala sibilant harmony be captured with a right-to-left FST?
1. Can Samala sibilant harmony be captured with the left-to-right FST that uses the delayed output strategy?
:::

We could still look at many other phenomena, but the central point should be clear by now: the simple and elegant mechanism of connecting states via transitions allows us to capture wide range of phonological phenomena.
No extra tweaks or extensions are required to capture locality, unboundedness, iterativity, tiers, blocking, and much more.
They are all particular instantiations of the same basic machinery.

::: exercise
The two following statements are true.
Explain why.

When using total deterministic FSTs,

- there are phenomena that can be captured by the right-to-left strategy but not the delayed-output strategy, and
- there are phenomena that can be captured by the delayed-output strategy but not the right-to-left strategy.
:::

::: exercise
Many languages not only use different sounds but also different tones, e.g. high tone H and low tone L.
Some of those languages have a process known as unbounded tone plateauing: a low tone that occurs inside an interval spanned by two high tones becomes a high tone, no matter how far apart those high tones are.
As a rewrite rule, this could be represented as follows:

$$\mathrm{L} \rightarrow \mathrm{H} \mid \mathrm{H} \ldots \_ \ldots \mathrm{H}$$

The table below shows a few examples of this process.

| **Underlying representation** | **Surface form** |
| --:                           | :--              |
| LLLLL                         | LLLLL            |
| LHLLL                         | LHLLL            |
| LLLHL                         | LLLHL            |
| LHLHL                         | LHHHL            |
| LHLLH                         | LHHHH            |
| HLLLH                         | HHHHH            |
| LHLHLLHLH                     | LHHHHHHHH        |

Give a non-deterministic FST that correctly handles unbounded tone plateauing.
:::

::: exercise
Unbounded tone plateauing is an example of a circumambient phenomenon.
A phenomenon is circumambient iff changing a segment *s* requires a trigger to the left of *s* and a trigger to the right of *s* such that both triggers may be arbitrarily far away from *s*.
Total deterministic FSTs cannot handle such circumambient phenomena.
This holds irrespective of whether the total deterministic FST operates left-to-right or right-to-left, and irrespective of whether it uses delayed outputs and/or final emissions.
Explain why!
:::

## Recap

- FSTs allow us model a variety of phonological phenomena as the rewriting of URs into surface forms.
- Total deterministic FSTs are weaker than non-deterministic FSTs, but they nonetheless can handle a large variety of phenomena:
    - locally bounded phenomena (progressive and regressive), and
    - unbounded phenomena/tier-based phenomena (progressive and regressive), and
    - iterative phenomena and spreading, and
    - phenomena that involve blocking.
- Some phenomena require total deterministic FSTs that operate **right-to-left** instead of left-to-right.
- Some phenomena require the **delayed output strategy**: delete the symbol, then reinsert it later on when the conditioning context has been fully read in.
  This only works if there is a fixed upper bound on how long the output has to be delayed.
- The delayed output strategy often has to be used in conjunction with **final emissions**, which rewrite {{{R}}} as a sequence of 0 or more output symbols.
