<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>The mathematics of tiers</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/main/style.css" />
  <!-- Include this in HTML headers to configure and activate MathJax. -->
  <script>
  MathJax = {
      loader: {
          load: ['a11y/assistive-mml']
      },
      options: {
          enableMenu: true,          // set to false to disable the menu
          menuOptions: {
              settings: {
                  assistiveMml: true,   // true to enable assitive MathML
              }
          }
      }
  };
  </script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="container with-sidebar">
<div class="sidenav">
<nav id="TOC" role="doc-toc">
<p><a id="site-title" href="/main">Language, Math, and Computation</a></p>
<ul>
<li><a href="#the-mathematics-of-tiers">The mathematics of tiers</a>
<ul>
<li><a href="#tier-projection-as-a-mapping">Tier projection as a
mapping</a></li>
<li><a href="#adding-tiers-to-n-gram-grammars">Adding tiers to <span
class="math inline">\(n\)</span>-gram grammars</a></li>
<li><a href="#a-big-change-without-big-changes">A big change without big
changes</a></li>
<li><a href="#recap">Recap</a></li>
</ul></li>
</ul>
</nav>
</div>
<div class="content">
<h1 id="the-mathematics-of-tiers">The mathematics of tiers</h1>
<div class="prereqs">
<ul>
<li>functions (domains and co-domains)</li>
<li>tuples (pairs)</li>
</ul>
</div>
<p>Tiers are a nice linguistic metaphor, but what is going on here at a
formal level? How do we specify tiers, and how significant a
modification are tiers? Also, what exactly is the cognitive intuition
behind tiers? These are great questions with some great answers.</p>
<h2 id="tier-projection-as-a-mapping">Tier projection as a mapping</h2>
<p>Mathematically, tiers are easily defined as the output of a
<strong>tier projection</strong> function <span
class="math inline">\(\tau\)</span> (this is the Greek letter
<em>tau</em>). Each type of tier comes with its own projection function
<span class="math inline">\(\tau_T\)</span>, which takes a string
<em>s</em> as its only argument. Here <span
class="math inline">\(T\)</span> is the <strong>tier alphabet</strong>,
i.e. the set of symbols that should be projected onto said tier. The
tier projection function <span class="math inline">\(\tau_T\)</span>
then deletes every symbol from string <em>s</em> that isn’t a member of
<span class="math inline">\(T\)</span>.</p>
<div class="definition">
<p>Given alphabets <span class="math inline">\(\Sigma\)</span> and <span
class="math inline">\(T\)</span>, the <strong>tier projection</strong>
function <span class="math inline">\(\tau_T: \Sigma^* \rightarrow
T^*\)</span> maps each <span
class="math inline">\(\Sigma\)</span>-string <span
class="math inline">\(s\)</span> to the longest subsequence <span
class="math inline">\(u\)</span> of <span
class="math inline">\(s\)</span> such that <span
class="math inline">\(u\)</span> is a <span
class="math inline">\(T\)</span>-string.</p>
</div>
<div class="example">
<p>Consider once more the case of Samala sibilant harmony. Since the set
of sibilants contains only <em>s</em> and <em>ʃ</em>, the tier alphabet
<span class="math inline">\(T\)</span> for the sibilant tier contains
those two symbols and nothing else. And <span
class="math inline">\(\tau_T(\mathit{hasxintilawas}) =
\mathit{ss}\)</span>.</p>
</div>
<div class="example">
<p>As an abstract example, consider the set of all strings over <span
class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>, and <span
class="math inline">\(c\)</span>. Then the <span
class="math inline">\(a\)</span>-tier of <span
class="math inline">\(\mathit{abbca}\)</span> would be <span
class="math inline">\(\tau_\left \{ a \right \}(\mathit{abbca}) =
\mathit{aa}\)</span>, whereas the tier of <span
class="math inline">\(a\)</span>s and <span
class="math inline">\(b\)</span>s would be <span
class="math inline">\(\tau_\left \{ a,b \right \}(\mathit{abbca}) =
\mathit{abba}\)</span>.</p>
</div>
<div class="exercise">
<p>Look at the list below, which shows <span
class="math inline">\(\Sigma\)</span>-strings being mapped to <span
class="math inline">\(T\)</span>-strings by some tier projection
function. Write down the smallest possible tier alphabet <span
class="math inline">\(T\)</span> that gives rise to all these
mappings.</p>
<ol type="1">
<li><span class="math inline">\(\mathit{aaca} \mapsto
\mathit{aaa}\)</span></li>
<li><span class="math inline">\(\mathit{cabab} \mapsto
\mathit{abab}\)</span></li>
<li><span class="math inline">\(\mathit{bbdbe} \mapsto
\mathit{bbdbe}\)</span></li>
</ol>
</div>
<div class="exercise">
<p>Compute each one of the following:</p>
<ol type="1">
<li><span class="math inline">\(\tau_\left \{ a \right
\}(\mathit{abca})\)</span></li>
<li><span class="math inline">\(\tau_\left \{ a,b \right
\}(\mathit{abca})\)</span></li>
<li><span class="math inline">\(\tau_\left \{ a,b,c \right
\}(\mathit{abca})\)</span></li>
<li><span class="math inline">\(\tau_\left \{ a,b \right
\}(\mathit{ccc})\)</span></li>
<li><span class="math inline">\(\tau_\left \{ a,b,c \right
\}(\varepsilon)\)</span></li>
<li><span
class="math inline">\(\tau_\emptyset(\mathit{abc})\)</span></li>
</ol>
</div>
<div class="exercise">
<p>Explain why, per the definition above, the domain of <span
class="math inline">\(\tau_T\)</span> is <span
class="math inline">\(\Sigma^*\)</span> while its co-domain is <span
class="math inline">\(T^*\)</span>.</p>
</div>
<h2 id="adding-tiers-to-n-gram-grammars">Adding tiers to <span
class="math inline">\(n\)</span>-gram grammars</h2>
<p>Now that we have a formal way to specify tiers, it is very easy to
graft tiers onto <span class="math inline">\(n\)</span>-gram grammars by
tying <span class="math inline">\(n\)</span>-grams to specific tiers.
The idea is that each <span class="math inline">\(n\)</span>-gram now
says explicitly which tier it applies to.</p>
<div class="definition">
<p>A <strong>(strict) negative tier <span
class="math inline">\(n\)</span>-gram grammar</strong> over alphabet
<span class="math inline">\(\Sigma\)</span> is a finite set of pairs
<span class="math inline">\(\left \langle g_i, T_i \right
\rangle\)</span> such that</p>
<ul>
<li>each <span class="math inline">\(T_i\)</span> is a finite set of
symbols drawn from <span class="math inline">\(\Sigma\)</span>, and</li>
<li><span class="math inline">\(g_i \in T_i^n\)</span>.</li>
</ul>
<p>We call <span class="math inline">\(T\)</span> a <strong>tier of
<span class="math inline">\(G\)</span></strong> iff <span
class="math inline">\(\left \langle g, T \right \rangle \in G\)</span>
for some <span class="math inline">\(g\)</span>, and we call the set of
all such <span class="math inline">\(g\)</span> the <strong><span
class="math inline">\(T\)</span>-subgrammar <span
class="math inline">\(G_T\)</span></strong> of <span
class="math inline">\(G\)</span>. A <span
class="math inline">\(\Sigma\)</span>-string <span
class="math inline">\(s\)</span> is well-formed with respect to <span
class="math inline">\(G_T\)</span> iff there is no <span
class="math inline">\(g \in G_T\)</span> that is a factor of <span
class="math inline">\(\tau_T(s)\)</span>. It is well-formed with respect
to <span class="math inline">\(G\)</span> iff it is well-formed with
respect to <span class="math inline">\(G_T\)</span> for every tier <span
class="math inline">\(T\)</span> of <span
class="math inline">\(G\)</span>. The <strong>stringset/language
generated by <span class="math inline">\(G\)</span></strong> is the set
<span class="math inline">\(L(G)\)</span> that contains all strings, and
only those, that are well-formed with respect to <span
class="math inline">\(G\)</span>.</p>
</div>
<p>(The definition above uses the term <strong>factor</strong> that was
first introduced in the formal definition of negative <span
class="math inline">\(n\)</span>-gram grammars. We call an <span
class="math inline">\(n\)</span>-gram a factor of string <span
class="math inline">\(s\)</span> iff it is an <span
class="math inline">\(n\)</span>-gram of <span
class="math inline">\({\rtimes}^{n-1} s {\ltimes}^{n-1}\)</span>.)</p>
<div class="example">
<p>Recall that we captured Korean vowel harmony by projecting all bright
vowels (B) and all mid dark vowels (M) onto a dedicated tier and banning
BM and MB on this tier. More formally: let <span
class="math inline">\(G\)</span> be the set <span
class="math inline">\(\left \{  \left \langle \mathrm{BM}, \left \{
\mathrm{B}, \mathrm{M} \right \} \right \rangle, \left \langle
\mathrm{MB}, \left \{ \mathrm{B}, \mathrm{M} \right \} \right
\rangle  \right \}\)</span>. Then <span
class="math inline">\(L(G)\)</span> is the set of strings that obey
Korean vowel harmony.</p>
<p>Note that since <span class="math inline">\(G\)</span> only contains
the one tier above, it is identical to the subgrammar for that tier. In
other words, <span class="math inline">\(G = G_\left \{ \mathrm{B},
\mathrm{M} \right \}\)</span>.</p>
</div>
<div class="exercise">
<p>The example above uses abstract symbols like B and M instead of the
actual vowels. Suppose that the only bright vowels of Korean are
<em>a</em> and <em>u</em>, and the only mid dark vowel is <em>o</em>
(just to be clear, this is not at all how Korean works). Adapt <span
class="math inline">\(G\)</span> above to use these vowels instead of B
and M.</p>
</div>
<div class="exercise">
<p>The term <strong>culminativity</strong> refers to the property that
every word has exactly one primary stress. Suppose that our alphabet is
<span class="math inline">\(\{ V, \acute{V} \}\)</span>, where <span
class="math inline">\(V\)</span> denotes the vowel of an unstressed
syllable and <span class="math inline">\(\acute{V}\)</span> the vowel of
a syllable with primary stress (we assume for simplicity that every
syllable has exactly one vowel). Propose a negative tier bigram grammar
<span class="math inline">\(G\)</span> such that <span
class="math inline">\(L(G)\)</span> is the set of all strings over <span
class="math inline">\(V\)</span> and <span
class="math inline">\(\acute{V}\)</span> that obey culminativity.</p>
<p><em>Hint</em>: ⋊ and ⋉ can be used with tiers, too.</p>
</div>
<div class="exercise">
<p>This continues the previous exercises. Suppose that <span
class="math inline">\(a\)</span> and <span
class="math inline">\(u\)</span> are bright vowels in unstressed
syllables and <span class="math inline">\(o\)</span> is a mid dark vowel
in an unstressed syllable, whereas <span
class="math inline">\(\acute{a}\)</span>, <span
class="math inline">\(\acute{u}\)</span>, and <span
class="math inline">\(\acute{o}\)</span> are their counterparts in
stressed syllables. Propose a tier bigram grammar <span
class="math inline">\(G\)</span> such that <span
class="math inline">\(L(G)\)</span> is the set of all strings that obey
both Korean vowel harmony and culminativity.</p>
<p><em>Hint</em>: You will need two separate tiers.</p>
</div>
<div class="exercise">
<p>Give a definition for positive tier <span
class="math inline">\(n\)</span>-gram grammars.</p>
</div>
<h2 id="a-big-change-without-big-changes">A big change without big
changes</h2>
<p>Even though tiers make <span class="math inline">\(n\)</span>-gram
grammars a lot more flexible and greatly broadens their empirical
coverage, they are a fairly innocuous change from a mathematical
perspective. First, observe that the <span
class="math inline">\(n\)</span>-gram grammars we had been looking at
before the introduction of tiers can be regarded as just a special case
of tier <span class="math inline">\(n\)</span>-gram grammars where all
<span class="math inline">\(n\)</span>-grams use the tier projection
<span class="math inline">\(\tau_\Sigma\)</span>.</p>
<div class="example">
<p>Remember our negative bigram grammar <span
class="math inline">\(G\)</span> for CV syllable templates? The grammar
uses the alphabet <span class="math inline">\(\Sigma
\mathrel{\mathop:}=\left \{  \mathrm{C}, \mathrm{V}  \right \}\)</span>
and consists of four forbidden bigrams:</p>
<ol type="1">
<li><span class="math inline">\({\rtimes}\mathrm{V}\)</span></li>
<li><span class="math inline">\(\mathrm{CC}\)</span></li>
<li><span class="math inline">\(\mathrm{VV}\)</span></li>
<li><span class="math inline">\(\mathrm{C}{\ltimes}\)</span></li>
</ol>
<p>But we can also regard this as a tier bigram grammar <span
class="math inline">\(G&#39;\)</span> that contains the following
pairs:</p>
<ol type="1">
<li><span class="math inline">\(\left \langle  {\rtimes}\mathrm{V},
\Sigma \right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  \mathrm{CC}, \Sigma
\right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  \mathrm{VV}, \Sigma
\right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  \mathrm{C}{\ltimes},
\Sigma \right \rangle\)</span></li>
</ol>
<p>These two grammars generate exactly the same string language. That’s
because no matter what string <span class="math inline">\(s\)</span>
over <span class="math inline">\(\Sigma\)</span> one picks, it always
holds that <span class="math inline">\(\tau_\Sigma(s) = s\)</span>. That
the n-grams of <span class="math inline">\(G&#39;\)</span> apply to a
tier of <span class="math inline">\(s\)</span> instead of <span
class="math inline">\(s\)</span> itself is irrelevant because said tier
looks exactly the same as <span class="math inline">\(s\)</span>.</p>
</div>
<p>The fact that every <span class="math inline">\(n\)</span>-gram
grammar is a tier <span class="math inline">\(n\)</span>-gram grammar
not only tells us that this is a very natural generalization, it also
makes it easy to generalize our findings about <span
class="math inline">\(n\)</span>-gram grammars to tier <span
class="math inline">\(n\)</span>-gram grammars. This barely requires any
work at all. We just have to take the procedures we already know and
carry them out for each tier.</p>
<p>Consider the case of polarity conversion, i.e. that every positive
<span class="math inline">\(n\)</span>-gram grammar has an equivalent
negative <span class="math inline">\(n\)</span>-gram grammar and the
other way round. This also holds for tier <span
class="math inline">\(n\)</span>-gram grammars.</p>
<div class="example">
<p>Let <span class="math inline">\(G\)</span> be the tier bigram grammar
over alphabet <span class="math inline">\(\left \{ a,b \right
\}\)</span> that contains the following pairs, and only those:</p>
<ul>
<li><span class="math inline">\(\left \langle  {\rtimes}{\ltimes}, \left
\{ a \right \}  \right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  bb, \left \{ b \right
\}  \right \rangle\)</span></li>
</ul>
<p>Here <span class="math inline">\(N(G)\)</span> (i.e. the string
language under the negative interpretation of <span
class="math inline">\(G\)</span>) consists of all strings that contain
at least one <span class="math inline">\(a\)</span> and at most one
<span class="math inline">\(b\)</span>.</p>
<p>We can construct another tier bigram grammar <span
class="math inline">\(G&#39;\)</span> such that <span
class="math inline">\(N(G) = P(G&#39;)\)</span>. This grammar looks as
follows:</p>
<ul>
<li><span class="math inline">\(\left \langle  {\rtimes}a, \left \{ a
\right \}  \right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  a{\ltimes}, \left \{ a
\right \}  \right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  {\rtimes}{\ltimes}, \left
\{ b \right \}  \right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  {\rtimes} b, \left \{ b
\right \}  \right \rangle\)</span></li>
<li><span class="math inline">\(\left \langle  b {\ltimes}, \left \{ b
\right \}  \right \rangle\)</span></li>
</ul>
<p>Does this look familiar to you? For each tier <span
class="math inline">\(T\)</span> of <span
class="math inline">\(G\)</span>, <span
class="math inline">\(G&#39;\)</span> contains every pair <span
class="math inline">\(\left \langle g, T \right \rangle\)</span> such
that <span class="math inline">\(g\)</span> is a bigram but <span
class="math inline">\(\left \langle g, T \right \rangle\)</span> isn’t a
member of <span class="math inline">\(G\)</span>. Just like in the
original conversion procedure for <span
class="math inline">\(n\)</span>-gram grammars, <span
class="math inline">\(G&#39;\)</span> contains every bigram that isn’t a
bigram of <span class="math inline">\(G\)</span>. All we have done is
take the original procedure and carry it out for each tier of <span
class="math inline">\(G\)</span>.</p>
</div>
<p>Note that we do not even have to write an entirely new proof to show
that polarity conversion is always possible for tier <span
class="math inline">\(n\)</span>-gram grammars. Instead, a simple
<strong>lemma</strong> suffices. A <strong>lemma</strong> is a theorem
that isn’t very interesting on its own but helps us in establishing
things that are interesting.</p>
<div class="lemma">
<p>Let <span class="math inline">\(G\)</span> and <span
class="math inline">\(G&#39;\)</span> be tier <span
class="math inline">\(n\)</span>-gram grammars over <span
class="math inline">\(\Sigma\)</span> such that every tier <span
class="math inline">\(T\)</span> of <span
class="math inline">\(G\)</span> is also a tier of <span
class="math inline">\(G&#39;\)</span>, and the other way round. Then
<span class="math inline">\(G\)</span> and <span
class="math inline">\(G&#39;\)</span> generate the same string language
if for every tier <span class="math inline">\(T\)</span> of <span
class="math inline">\(G\)</span>/<span
class="math inline">\(G&#39;\)</span>, there is no</p>
</div>
<div class="exercise">
<p>Note that the lemma uses <em>if</em> instead of <em>iff</em>. Can you
think of a case where two grammars disagree on the well-formedness of
specific tiers but still generate the same string language?</p>
</div>
<ul>
<li>mixed can be made strict</li>
<li>polarity conversion still the same</li>
<li>combination via intersection/union</li>
</ul>
<h2 id="recap">Recap</h2>
<p>fixme</p>
</div>
</div>
</body>
</html>
