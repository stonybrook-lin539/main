"""
Classes for n-gram grammars.
"""

from functools import partial
from itertools import islice, chain
import random

from util import substrings_len_k_of, language_sigma_up_to_k, padlr


class NGramGrammar:

    min_n = 2
    l_edge_sym = '>'
    r_edge_sym = '<'

    def __init__(self, alphabet, n, ngrams):
        """
        alphabet -- set or string of characters, not including edge symbols
        n -- length of n-grams
        ngrams -- set or list of ngrams
        """
        if isinstance(alphabet, str):
            alphabet = set(alphabet)
        if isinstance(ngrams, list):
            ngrams = set(ngrams)

        augalph = alphabet | {self.l_edge_sym, self.r_edge_sym}
        for sym in (self.l_edge_sym, self.r_edge_sym):
            if sym in alphabet:
                raise ValueError(f"Alphabet must not include symbol '{sym}'.")
        if n < self.min_n:
            raise ValueError(f"Parameter 'n' must be >= {self.min_n}.")
        for ngram in ngrams:
            if len(ngram) != n:
                raise ValueError(f"N-gram '{ngram}' not length {n}.")
            if not set(ngram).issubset(augalph):
                raise ValueError(
                    f"N-gram '{ngram}' contains symbol not in alphabet.")

        self.alphabet = alphabet
        self.augalph = augalph
        self.n = n
        self.ngrams = ngrams

    @classmethod
    def from_corpus(corpus, n):
        """
        Generate grammar from (partial) corpus of a language. Must be
        implemented by subclass.
        """
        raise NotImplementedError

    def pad(self, s):
        """
        Return string padded with the appropriate number of edge symbols.
        """
        n_edge_syms = self.n - 1
        return padlr(s, self.l_edge_sym, self.r_edge_sym, n_edge_syms)

    def match(self, string):
        """
        Return True if grammar matches string. Must be implemented by subclass.
        """
        raise NotImplementedError

    def gen_language(self, max_len):
        """
        Return generator over language of grammar including strings up to max_len.
        Tests all possible strings up to max_len, so may be very slow.
        """
        sigma_k = language_sigma_up_to_k(self.alphabet, max_len)
        yield from (s for s in sigma_k if self.match(s))

    def gen_language_fast(self, max_len, randomize=False):
        """
        Optimized version of gen_language. Must be implemented by subclass.
        """
        raise NotImplementedError

    def gen_strings(self, max_len, n, randomize=False):
        """Return `n` strings up to `max_len` generated by the grammar."""
        lang = [s for s in islice(self.gen_language(max_len), n)]
        if randomize:
            random.shuffle(lang)
        return lang

    def gen_strings_fast(self, max_len, n, randomize=False):
        """Return `n` strings up to `max_len` generated by the grammar."""
        lang = [s for s in islice(self.gen_language_fast(max_len), n)]
        if randomize:
            random.shuffle(lang)
        return lang


class PosNGramGrammar(NGramGrammar):

    @classmethod
    def from_corpus(cls, alphabet, n, corpus):
        """
        Return smallest grammar that accepts all strings in the given corpus.
        """
        n_edge_syms = n - 1
        padn = partial(padlr, left=cls.l_edge_sym, right=cls.r_edge_sym,
                       n=n_edge_syms)
        ngrams = set(chain.from_iterable(substrings_len_k_of(padn(s), n)
                                         for s in corpus))
        return cls(alphabet, n, ngrams)

    def __str__(self):
        left_edge_ngrams = sorted([g for g in self.ngrams
                                   if '>' in g],
                                  key=lambda s: (-s.count('>')))
        right_edge_ngrams = sorted([g for g in self.ngrams
                                    if '<' in g and '>' not in g],
                                   key=lambda s: (s.count('<')))
        middle_ngrams = sorted([g for g in self.ngrams
                                if '>' not in g and '<' not in g])
        sorted_ngrams = left_edge_ngrams + middle_ngrams + right_edge_ngrams
        return f"G(+): {{{','.join(sorted_ngrams)}}}"

    def match(self, string):
        return all(ss in self.ngrams
                   for ss in substrings_len_k_of(self.pad(string), self.n))

    def _possible_continuations(self, prefix):
        """
        Return list of possible characters that may follow prefix. The list
        may be nonempty even if the given prefix is itself illicit.
        """
        return [ng[-1] for ng in self.ngrams
                if prefix.endswith(ng[:-1])]

    def gen_language_fast(self, max_len):
        """
        Optimized version of gen_language. Considers only strings that can
        be created by adding to valid prefixes.
        """
        n_edge_syms = self.n - 1
        init_prefix = self.l_edge_sym * n_edge_syms
        final_suffix = self.r_edge_sym * n_edge_syms
        edge_syms = self.l_edge_sym + self.r_edge_sym
        prefixes = [init_prefix]
        for i in range(max_len + n_edge_syms):
            old_prefixes = prefixes
            prefixes = []
            for pre in old_prefixes:
                for suf in self._possible_continuations(pre):
                    newstr = pre + suf
                    if len(newstr) >= max_len + 2 * n_edge_syms:
                        break
                    elif newstr.endswith(final_suffix):
                        yield newstr.strip(edge_syms)
                    else:
                        prefixes.append(newstr)

    # def gen_random_string(self, max_len):
    #     """
    #     max_len -- maximum length of string to generate
    #     """
    #     chars = random.choice(self.ngrams)
    #     while len(chars) < max_len:
    #         for ng in sorted(self.ngrams, key=lambda _: random.random()):
    #             if chars[self.n-2] == ng[:self.n-1]:
    #                 chars += ng[self.n:]
    #         else:
    #             # no more possible continuations
    #             break
    #     return chars


class NegNGramGrammar(NGramGrammar):

    def __str__(self):
        left_edge_ngrams = sorted([g for g in self.ngrams if '>' in g],
                                  key=lambda s: (-s.count('>')))
        right_edge_ngrams = sorted([g for g in self.ngrams if '<' in g],
                                   key=lambda s: (s.count('<')))
        middle_ngrams = sorted([g for g in self.ngrams
                                if '>' not in g and '<' not in g])
        sorted_ngrams = left_edge_ngrams + middle_ngrams + right_edge_ngrams
        return f"G(-): {{{','.join(sorted_ngrams)}}}"

    def match(self, string):
        return not any(s in self.ngrams
                       for s in substrings_len_k_of(self.pad(string), self.n))

    def _possible_continuations(self, prefix):
        """
        Return list of possible characters that may follow prefix, based
        on whether any n-gram matches the end of the prefix. The list
        may be nonempty even if the given prefix is itself illicit.
        """
        if (prefix.endswith(self.r_edge_sym) and not
                any(prefix.endswith(ng[:-1])
                    for ng in self.ngrams if ng[-1] == self.r_edge_sym)):
            cont = [self.r_edge_sym]
        else:
            cont = [ch for ch in self.alphabet | {self.r_edge_sym}
                    if not any(prefix.endswith(ng[:-1])
                               for ng in self.ngrams if ng[-1] == ch)]
        return cont

    def gen_language_fast(self, max_len):
        """
        Optimized version of gen_language. Considers only strings that can
        be created by adding to valid prefixes.
        """
        n_edge_syms = self.n - 1
        init_prefix = self.l_edge_sym * n_edge_syms
        final_suffix = self.r_edge_sym * n_edge_syms
        edge_syms = self.l_edge_sym + self.r_edge_sym
        prefixes = [init_prefix]
        for i in range(max_len + n_edge_syms):
            old_prefixes = prefixes
            prefixes = []
            for pre in old_prefixes:
                for suf in self._possible_continuations(pre):
                    newstr = pre + suf
                    if len(newstr) >= max_len + 2 * n_edge_syms:
                        break
                    elif newstr.endswith(final_suffix):
                        yield newstr.strip(edge_syms)
                    else:
                        prefixes.append(newstr)


if __name__ == "__main__":
    g = PosNGramGrammar.from_corpus(3, "ab", ["aaa", "aba", "bab"])
    print(g)
    lang1 = list(g.gen_language(5))
    lang2 = list(g.gen_language_fast(5))
    print(lang1)
    print(lang2)
    print(lang1 == lang2)
    print(g.match("ababa"))
    print(g.match("abbba"))

    g2 = NegNGramGrammar(3, "ab", ["aaa", "bbb"])
    print(g2)
    lang1 = list(g2.gen_language(4))
    lang2 = list(g2.gen_language_fast(4))
    print(lang1)
    print(lang2)
    print(lang1 == lang2)
    print(g2.match("a"))
    print(g2.match("aaa"))
    print(g2.match("aaaa"))
