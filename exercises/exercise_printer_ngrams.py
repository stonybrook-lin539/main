"""
Question generators for strings.
"""

import string
import random
import re

from util import random_string, language_sigma_k
import question
import grammars


def choose_matching_strings(alpha_size=3, ngram_size=3, ngram_num=6,
                            str_size=8, n_choices=6):
    """
    Generate question asking student to select all strings that conform
    to the given grammar.

    We generate a random n-gram grammar, then randomly generate some strings
    that conform to the grammar and some that don't. There is a small chance
    that some of the "bad" strings may also conform to the grammar, but this
    isn't a problem because we later shuffle the list of choices and recheck
    them to generate the list of correct answers.
    """
    alphabet = string.ascii_lowercase[:alpha_size]
    grammar_type = random.choice(["positive", "negative"])
    grammar_gen = GRAMMAR_TYPES[grammar_type]
    mygrammar = grammar_gen(alphabet, ngram_size, ngram_num, str_size)

    n_good_choices = random.randrange(n_choices)
    choices = mygrammar.gen_strings_fast(str_size, n_good_choices, randomize=True)
    while len(choices) < n_choices:
        newchoice = random_string(alphabet, random.randrange(str_size + 1))
        if newchoice not in choices:
            choices.append(newchoice)
    random.shuffle(choices)

    prompt = (
        f"For each one of the strings below \
say whether it is generated by the following \
{grammar_type} {ngram_size}-gram grammar:\n {mygrammar}")
    answers = [i for i, c in enumerate(choices) if mygrammar.match(c)]
    return question.MultipleAnswerQuestion(prompt, choices, answers)


def _random_positive_grammar(alphabet, ngram_size, ngram_num, str_size):
    """
    Randomly generate some strings, then build grammar from this corpus.
    """
    corpus = [random_string(alphabet, str_size)]
    for i in range(ngram_size):
        if random.getrandbits(1):
            corpus.append(random_string(alphabet, i))
    return grammars.PosNGramGrammar.from_corpus(alphabet, ngram_size, corpus)


def _random_negative_grammar(alphabet, ngram_size, ngram_num, str_size):
    """
    Randomly generate some n-grams, then build grammar from these.
    """
    ngrams = random.sample(language_sigma_k(alphabet, ngram_size), ngram_num)
    return grammars.NegNGramGrammar(alphabet, ngram_size, ngrams)


GRAMMAR_TYPES = {"positive": _random_positive_grammar,
                 "negative": _random_negative_grammar}


def _pandocify_string(pythonstring):
    if not pythonstring:
        return r"$\varepsilon$"

    pythonstring = pythonstring.replace("\n", "  \n")
    pythonstring = pythonstring.replace("'", "")
    pythonstring = pythonstring.replace("{", "$\{")
    pythonstring = pythonstring.replace("}", "\}$")
    pythonstring = pythonstring.replace(">", "{{{L}}}")
    pythonstring = pythonstring.replace("<", "{{{R}}}")
    pythonstring = pythonstring.replace("G(+)", "$G^+$")
    pythonstring = re.sub(r"G\(.\)", r"$G^-$", pythonstring)
    return pythonstring


def _pandocify_list(pythonlist):
    liststring = ""
    for s in pythonlist:
        s = _pandocify_string(s)
        liststring += f"1. {s}\n"
    return liststring


def _pandocify_exercise(exercise):
    prompt = _pandocify_string(exercise.prompt)
    choices = _pandocify_list(exercise.choices)
    idxanswers = ", ".join(str(answer + 1) for answer in exercise.answeridxlst)
    answers = []
    for pos in range(len(exercise.choices)):
        answer = "Yes" if pos in exercise.answeridxlst else "No"
        answers.append(answer)
    answers = _pandocify_list(answers)
    return {'prompt': prompt,
            'choices': choices,
            'answers': answers,
            'idxanswers': idxanswers}


def _batchgen_exercises(batchsize=10):
    exercises = []
    while len(exercises) <= batchsize:
        alpha_size = random.randint(2, 5)
        ngram_size = random.randint(2, 4)
        ngram_num = random.randint(4, 8)
        str_size = random.randint(6, 12)
        n_choices = 4
        try:
            q = _pandocify_exercise(choose_matching_strings(
                alpha_size=alpha_size,
                ngram_size=ngram_size,
                ngram_num=ngram_num,
                str_size=str_size,
                n_choices=n_choices))
            exercises.append(q)
        except:
            continue
    return exercises


def _print_exercise(exercise, solution_type="list"):
    answers = exercise['answers']\
        if solution_type == "list" else exercise['idxanswers']
    return f"""::: exercise

{exercise['prompt']}

{exercise['choices']}

::: solution

{answers}
:::

:::

"""


def create_exercisesheet(batchsize=100,
                         filename=None,
                         exercises=None,
                         title="Exercises with n-gram grammars"):
    if not filename:
        filename = f"{batchsize}_ngramexercises.md"
    if not exercises:
        exercises = _batchgen_exercises(batchsize=batchsize)
    with open(filename, "a") as exfile:
        exfile.write(f"# {title}\n\n")
        for i in range(batchsize):
            exfile.write(_print_exercise(exercises[i]))


def test():
    q = choose_matching_strings()
    print(q)


if __name__ == "__main__":
    create_exercisesheet()
