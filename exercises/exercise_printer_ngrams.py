"""
Question generators for strings.
"""

import string
import random
import re

from util import random_string, language_sigma_k
import question
import grammars


def choose_matching_strings(alpha_size=3, ngram_size=3, ngram_num=6,
                            str_size=8, n_choices=6):
    """
    Generate question asking student to select all strings that conform
    to the given grammar.

    We generate a random n-gram grammar, then randomly generate some strings
    that conform to the grammar and some that don't. There is a small chance
    that some of the "bad" strings may also conform to the grammar, but this
    isn't a problem because we later shuffle the list of choices and recheck
    them to generate the list of correct answers.
    """
    alphabet = string.ascii_lowercase[:alpha_size]
    grammar_type = random.choice(["positive", "negative"])
    grammar_gen = GRAMMAR_TYPES[grammar_type]
    mygrammar = grammar_gen(alphabet, ngram_size, ngram_num, str_size)

    n_good_choices = random.randrange(n_choices)
    choices = mygrammar.gen_strings_fast(str_size, n_good_choices, randomize=True)
    while len(choices) < n_choices:
        newchoice = random_string(alphabet, random.randrange(str_size + 1))
        if newchoice not in choices:
            choices.append(newchoice)
    random.shuffle(choices)

    prompt = (
        f"For each one of the strings below \
say whether it is generated by the following n-gram grammar:\n {mygrammar}")
    answers = [i for i, c in enumerate(choices) if mygrammar.match(c)]
    return question.MultipleAnswerQuestion(prompt, choices, answers)


def _random_positive_grammar(alphabet, ngram_size, ngram_num, str_size):
    """
    Randomly generate some strings, then build grammar from this corpus.
    """
    corpus = [random_string(alphabet, str_size)]
    for i in range(ngram_size):
        if random.getrandbits(1):
            corpus.append(random_string(alphabet, i))
    return grammars.PosNGramGrammar.from_corpus(alphabet, ngram_size, corpus)


def _random_negative_grammar(alphabet, ngram_size, ngram_num, str_size):
    """
    Randomly generate some n-grams, then build grammar from these.
    """
    ngrams = random.sample(language_sigma_k(alphabet, ngram_size), ngram_num)
    return grammars.NegNGramGrammar(alphabet, ngram_size, ngrams)


GRAMMAR_TYPES = {"positive": _random_positive_grammar,
                 "negative": _random_negative_grammar}


def _pandocify_string(pythonstring):
    if not pythonstring:
        return r"$\varepsilon$"

    pythonstring = pythonstring.replace("\n", "  \n")
    pythonstring = pythonstring.replace("'", "")
    pythonstring = pythonstring.replace("{", "$\{")
    pythonstring = pythonstring.replace("}", "\}$")
    pythonstring = pythonstring.replace(">", "{{{L}}}")
    pythonstring = pythonstring.replace("<", "{{{R}}}")
    pythonstring = re.sub(r"G\((.)\)", r"$G^\1$", pythonstring)
    return pythonstring


def _pandocify_list(l):
    liststring = ""
    for s in l:
        s = _pandocify_string(s)
        liststring += f"1. {s}\n"
    return liststring


def _pandocify_exercise(exercise):
    prompt = _pandocify_string(exercise.prompt)
    choices = _pandocify_list(exercise.choices)
    answers = []
    for pos in range(1, len(exercise.choices) + 1):
        if pos in exercise.answeridxlst:
            answers.append("Yes")
        else:
            answers.append("No")
    answers = _pandocify_list(answers)
    return {'prompt': prompt,
            'choices': choices,
            'answers': answers}


def _batchgen_exercises(batchsize=10):
    exercises = []
    while len(exercises) <= batchsize:
        alpha_size = random.randint(2, 5)
        ngram_size = random.randint(2, 4)
        ngram_num = random.randint(4, 8)
        str_size = random.randint(6, 12)
        n_choices = 4
        try:
            q = _pandocify_exercise(choose_matching_strings(
                alpha_size=alpha_size,
                ngram_size=ngram_size,
                ngram_num=ngram_num,
                str_size=str_size,
                n_choices=n_choices))
            exercises.append(q)
        except:
            continue
    return exercises


def _print_exercise(exercise):
    return f"""::: exercise

{exercise['prompt']}

{exercise['choices']}

::: solution

{exercise['answers']}
:::

:::

"""


def create_exercisesheet(batchsize=100, filename=None, exercises=None):
    if not filename:
        filename = f"{batchsize}_ngramexercises.md"
    if not exercises:
        exercises = _batchgen_exercises(batchsize=batchsize)
    with open(filename, "a") as exfile:
        for i in range(batchsize):
            exfile.write(_print_exercise(exercises[i]))


def test():
    q = choose_matching_strings()
    print(q)


if __name__ == "__main__":
    test()
